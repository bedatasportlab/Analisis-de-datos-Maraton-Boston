---
title: "Análisis Exploratorio de Datos. La Maratón de Tokyo 2025."
author:
  - "Alba Martínez de la Hermosa"
  - "Alonso González Romero"
  - "Daniel López Paredes"
date: "2025-10-16"
format: html
toc: true
toc-depth: 2
number-sections: true
lang: es
keywords: ["maratón", "análisis de datos", "Tokyo"]
abstract: "MODIFICAR."
---

# Importación de librerías. 

```{r}
# Importación de todas las librerías usadas durante el informe y breve descripcion
library(readr) # Libreria para poder importar los datos desde un csv.
library(ggplot2) # Libreria para poder hacer gráficos.
library(DT) # Libreria para poder visualizar dataframes en qmd de manera interactiva.
library(hms) # Libreria para poder tratar datos referentes a horas, minutos y segundos.
library(dplyr) # Libreria para poder manipular dataframes.
library(ggplot2) # Libreria para poder hacer gráficos.
library(tidyr) # Libreria para poder transformar dataframes.
library(e1071) # para skewness() y kurtosis()
```

# Introducción
El **maratón de Tokyo 2025** se celebró, en su 18ª edición, el domingo 2 de marzo de 2025. Esta edición forma parte de los World Marathon Majors y abrió la temporada 2025 de los grandes maratones internacionales. El recorrido atraviesa distintos puntos icónicos de la ciudad de Tokyo, estando su inicio frente al edificio del Gobierno Metropolitano y la línea de meta cerca de la estación Tokyo/Gyoko-dori Avenue. El maratón de Tokyo es un evento de gran participación, tanto de atletas de élite como de aficionados. 

En el presente documento se realizará un análisis exploratorio de datos (EDA) con el objetivo de extraer información relevante acerca de los resultados de los corredores que participaron en dicha prueba.

# Presentación y Descripción del Dataset
Los resultados del maratón de Tokyo han sido extraídos a través del siguiente [enlace](https://www.marathon.tokyo/2025/result). La extracción se ha realizado a través de técnicas de Web Scrapping con el objetivo de poder obtener datos relevantes referentes a los resultados de los corredores participantes.

## Importación del Dataset

A continuación, se realiza la correspondiente importación de los datos extraídos:

```{r}
resultadosTokyo2025 <- read_csv(
  "data/Maraton_Tokyo/marathon_tokyo_results_2025.csv",
  col_types = cols(
    BIB = col_integer(),
    Nombre = col_character(),
    Nacionalidad = col_character(),
    Genero = col_character(),
    Edad = col_integer(),
    tiempo_oficial = col_time(format = "%H:%M:%S"),
    parcial_5km = col_time(format = "%H:%M:%S"),
    parcial_10km = col_time(format = "%H:%M:%S"),
    parcial_15km = col_time(format = "%H:%M:%S"),
    parcial_20km = col_time(format = "%H:%M:%S"),
    medio_maraton = col_time(format = "%H:%M:%S"),
    parcial_25km = col_time(format = "%H:%M:%S"),
    parcial_30km = col_time(format = "%H:%M:%S"),
    parcial_35km = col_time(format = "%H:%M:%S"),
    parcial_40km = col_time(format = "%H:%M:%S")
  ),
  quote = "\""
)

# Transformacion a formato dataframe.
resultadosTokyo2025 <- as.data.frame(resultadosTokyo2025)
```


## Descripción del Dataset
El dataframe importado, *resultadosTokyo2025*, consta de las siguientes variables: 

| Variable       | Tipo            | Descripción                                        | Unidades      |
| -------------- | --------------- | -------------------------------------------------- | ------------- |
| BIB            | Numérica/Entero | Número de dorsal asignado al corredor, valor único | Número entero |
| Nombre         | Cadena de texto | Nombre y apellidos del corredor                    | Texto         |
| Nacionalidad   | Cadena de texto | País de procedencia del corredor                   | Texto         |
| Genero         | Categórica      | Género del corredor                                | Texto         |
| Edad           | Numérica/Entero | Edad del corredor                                  | Años          |
| tiempo_oficial | Tiempo          | Tiempo total oficial de la maratón (gross time)    | hh:mm:ss      |
| parcial_5km    | Tiempo          | Tiempo de paso en el km 5                          | hh:mm:ss      |
| parcial_10km   | Tiempo          | Tiempo de paso en el km 10                         | hh:mm:ss      |
| parcial_15km   | Tiempo          | Tiempo de paso en el km 15                         | hh:mm:ss      |
| parcial_20km   | Tiempo          | Tiempo de paso en el km 20                         | hh:mm:ss      |
| medio_maraton  | Tiempo          | Tiempo al paso del medio maratón (21,097 km)       | hh:mm:ss      |
| parcial_25km   | Tiempo          | Tiempo de paso en el km 25                         | hh:mm:ss      |
| parcial_30km   | Tiempo          | Tiempo de paso en el km 30                         | hh:mm:ss      |
| parcial_35km   | Tiempo          | Tiempo de paso en el km 35                         | hh:mm:ss      |
| parcial_40km   | Tiempo          | Tiempo de paso en el km 40                         | hh:mm:ss      |


*Nota: El gross time es el tiempo que tarda un corredor en terminar la maratón desde que se da el pistoletazo de salida, no desde que cruza la línea de inicio de la prueba*
 
## Lectura de una fila

Una vez que conocemos el significado de cada variable por separado, se va a proceder a la lectura de la primera fila del *dataframe* con el objetivo de mejorar la comprensión sobre el formato de los datos:

```{r}
# Lo visualizamos con la libreria DT porque es más interactiva a la hora de generar el documento qmd.
datatable(
  resultadosTokyo2025,
  options = list(
    pageLength = 1, # cuántas filas mostrar
    scrollX = TRUE, # habilita scroll horizontal si la fila es muy ancha
    dom = 't' # solo muestra la tabla sin paginación ni búsqueda
  ),
  rownames = FALSE # quitar número de fila en la tabla
)

```

Se puede observar al corredor **Tadese Takele**, de nacionalidad **Etíope**, que corrió la maratón con el dorsal **número 5**. Tadese completó la maratón a sus 22 años con un tiempo de **2 horas, 3 minutos y 23 segundos**, pudiendose observar sus tiempos de paso cada 5 kilómetros y en el punto de la media maratón. 

## Dimensiones del dataset

```{r}
filas <- nrow(resultadosTokyo2025)
columnas <- ncol(resultadosTokyo2025)
cat(
  "El dataframe resultadosTokyo2025 contiene",
  filas,
  "filas y",
  columnas,
  "columnas."
)
# Elimino el número de filas y columnas con el objetivo de no sobrecargar el environment.
rm(filas, columnas)
```

## Descripción estadística del DataFrame

En este apartado se calculan las estadísticas para comprobar qué datos es necesario limpiar y posteriormente poder hacer un análisis fiable.
```{r}
#Estadísticas de Edad
resumen_edad <- data.frame(
    Minimo = min(resultadosTokyo2025$Edad, na.rm = TRUE),
    Maximo = max(resultadosTokyo2025$Edad, na.rm = TRUE),
    Media = round(mean(resultadosTokyo2025$Edad, na.rm = TRUE),2),
    Nulos = sum(is.na(resultadosTokyo2025$Edad))
)
resumen_edad
```

```{r}
#Estadísticas tiempo
cols_tiempo <- c("tiempo_oficial", "parcial_5km", "parcial_10km", "parcial_15km", "parcial_20km", "medio_maraton", "parcial_25km", "parcial_30km", "parcial_35km", "parcial_40km")

resultadosTokyo2025[cols_tiempo] <- lapply(resultadosTokyo2025[cols_tiempo], as_hms) #columnas a tipo hms

resumen_tiempos <- data.frame(
  Minimo = sapply(resultadosTokyo2025[cols_tiempo], min, na.rm = TRUE),
  Maximo = sapply(resultadosTokyo2025[cols_tiempo], max, na.rm = TRUE),
  Media  = sapply(resultadosTokyo2025[cols_tiempo], function(x) round(mean(x, na.rm = TRUE), 2)),
  Nulos  = sapply(resultadosTokyo2025[cols_tiempo], function(x) sum(is.na(x)))
)
resumen_tiempos
```

```{r}
#Estadísticas tiempos en hms
resumen_tiempos_convertidos <- data.frame (
  Minimo_hms = resumen_tiempos$Minimo <- as_hms((resumen_tiempos$Minimo)),
  Maximo_hms = resumen_tiempos$Maximo <- as_hms((resumen_tiempos$Maximo)),
  Media_hms = resumen_tiempos$Media <- as_hms((resumen_tiempos$Media)),
  Nulos  = sapply(resultadosTokyo2025[cols_tiempo], function(x) sum(is.na(x)))
)
resumen_tiempos_convertidos
```

## Limpieza de datos

### Datos faltantes

```{r}
#Filas con NA
filas_con_na <- resultadosTokyo2025[ rowSums(is.na(resultadosTokyo2025[cols_tiempo])) > 0, ]
which(is.na(resultadosTokyo2025[cols_tiempo]), arr.ind = TRUE)

#Filas con NA en cada columna
filas_con_na <- resultadosTokyo2025[rowSums(is.na(resultadosTokyo2025[cols_tiempo])) > 0, ]
head(filas_con_na, 20)
```

Hay 43 filas con columnas que contienen NA. Ahora hay que ver cuáles de esas columnas son las que tienen los NA para cada fila. O sea, ver para cada corredor, qué parcial le falta.

```{r}
texto_na <- "4377: parcial_5km, parcial_10km, parcial_15km, parcial_20km, medio_maraton, parcial_25km, parcial_30km, parcial_35km, parcial_40km
4713: parcial_25km
4909: parcial_15km, parcial_20km, parcial_30km
92503: parcial_5km, parcial_10km, parcial_15km, parcial_20km, parcial_25km, parcial_30km, parcial_35km, parcial_40km
9685: parcial_40km
10662: parcial_20km
10808: parcial_5km
11881: parcial_20km
12089: parcial_5km, parcial_10km, parcial_15km, parcial_20km, medio_maraton, parcial_25km, parcial_30km, parcial_35km, parcial_40km
12814: parcial_25km
12951: parcial_40km
12983: medio_maraton
13165: parcial_40km
14445: parcial_15km
14647: parcial_30km, parcial_35km, parcial_40km
14783: parcial_10km, parcial_15km
16263: parcial_15km
17239: parcial_20km
17945: parcial_25km
18094: parcial_40km, parcial_35km
19232: parcial_5km
19838: parcial_25km
19916: parcial_5km 
21392: parcial_5km
22564: parcial_5km, parcial_10km, parcial_15km, medio_maraton, parcial_25km
22724: parcial_10km
22734: parcial_25km
23848: parcial_25km
24137: parcial_20km
24377: parcial_25km
24562: parcial_5km
26547: parcial_25km
28195: parcial_40km
29145: parcial_20km, parcial_15km
29264: parcial_10km
29552: parcial_30km
30117: parcial_30km
31818: parcial_5km
32846: parcial_5km
33580: parcial_30km
34921: parcial_25km
35127: parcial_25km
36009: parcial_40km
"
```
```{r}
lineas <- strsplit(texto_na, "\n")[[1]] #separar el texto
lineas <- trimws(lineas[lineas != ""]) #quita celdas vacías y espacios

na_df <- data.frame(
  fila = sub(":.*", "", lineas), #hasta los dos puntos es la fila
  columnas = sub(".*:\\s*", "", lineas), #desde los dos puntos son las columnas
  stringsAsFactors = FALSE
)
```

Con esto ya se tiene un dataframe en el que aparecen las filas y al lado las correspondientes columnas donde se sitúan los valores NA.

Ahora se procede a la clasificación de esas filas según si faltan más de tres parciales (y por tanto se debe descartar a ese corredor porque no se puede hacer ningún cálculo) o si solo faltan 3 o menos, lo que permitirá estimar el parcial e imputarlo en el dataframe resultadosTokyo2025.

```{r}
#NA por fila
na_df$n_na <- sapply(na_df$columnas, function(x) {
  length(trimws(unlist(strsplit(x, ","))))
})

# Clasificar filas
na_df$clasificacion <- ifelse(
  na_df$n_na > 3, "descartar",   # más de 3 NAs → descartar
  "imputable"                    # 3 o menos NAs → se puede imputar
)

# Columna de descarte y filas a imputar
na_df$descarte <- na_df$clasificacion == "descartar"
filas_para_imputar <- na_df[na_df$descarte == FALSE, ]
```

**Aquí me falta imputar**

### Valores únicos - datos duplicados

```{r}
cols_para_duplicados <- c(cols_tiempo, "BIB")
valores_unicos <- lapply(resultadosTokyo2025[cols_para_duplicados], unique)
valores_unicos
```

```{r}
#Valores únicos por columna
n_unicos <- sapply(valores_unicos, length)

# Número de filas total
n_filas <- nrow(resultadosTokyo2025)

# Comprobar si hay duplicados
for(col in names(n_unicos)){
  if(n_unicos[col] == n_filas){
    message(paste("Columna", col, ": Ningún valor duplicado"))
  } else {
    message(paste("Columna", col, "tiene duplicados"))
  }
}
```

En este apartado se ha comprobado que no hay ningún corredor duplicado y que en todos los parciales hay valores duplicados, lo que significa que se pueden identificar grupos de carrera según el ritmo.

```{r}
for(col in cols_tiempo){
  freq <- table(resultadosTokyo2025[[col]])  # cuenta cuántas veces aparece cada valor
  duplicados <- freq[freq > 1]               # filtra solo los que aparecen más de una vez
  if(length(duplicados) > 0){
    cat("\nColumna:", col, "\n")
    print(duplicados)
  } else {
    cat("\nColumna:", col, "→ Ningún duplicado\n")
  }
}
```

**Aquí me falta ver si merece la pena agrupar los tiempos para identificar los grupos de carrera**

### Transformación de datos

### Validación de rangos

### Comprobación de calidad antes del análisis

## Análisis Univariante

DF TEMPORAL PARA EMPEZAR SECCION

```{r}
df_seconds <- resultadosTokyo2025 %>%
  mutate(
    across(
      matches("^tiempo_oficial$|^parcial_\\d+km$|^medio_maraton$"),
      ~ as.numeric(.x)
    )
  )

# Vista previa
glimpse(df_seconds)
```

<!-- Exploración de variables individuales: distribuciones, estadísticos descriptivos, etc. -->

Bajo este análisis se examinará cada variable del conjunto de datos para resumir su distribución, principales características y tendencias. Este tipo de análisis se centra en **una sola variable a la vez**, sin tener en cuenta su relación con otras, y permite obtener una primera descripción general de los datos. A continuación se revisa cada variable del dataset para observar sus principales características estadísticas.

### Edad

Esta variable indica la **edad** de los corredores que participaron en la maratón. Primero se examinán los principales estadísticos de centralización: media, moda y mediana

```{r}
# Fun. moda que devuelve el valor más frecuente (si hay empates devuelve el primero)
moda <- function(x) {
  x <- x[!is.na(x)]
  if (length(x) == 0) return(NA_real_)
  ux <- unique(x)
  ux[which.max(tabulate(match(x, ux)))]
}

# Estadísticos resumidos (redondeados)
edad_stats <- df_seconds %>%
  summarise(
    n = sum(!is.na(Edad)),
    n_missing = sum(is.na(Edad)),
    media = round(mean(Edad, na.rm = TRUE), 2),
    mediana = median(Edad, na.rm = TRUE),
    moda = moda(Edad),
  )

datatable(
  edad_stats,
  options = list(dom = 't'),
  rownames = FALSE
)

```

Representado de forma gráfica, en la siguiente figura se observa un histograma con línea de densidad y los correspondientes valores de media, mediana y moda.

```{r}

# Valores para líneas en los gráficos
mu <- edad_stats$media
med <- edad_stats$mediana
mod <- edad_stats$moda

p_hist <- ggplot(df_seconds, aes(x = Edad)) +
  geom_histogram(aes(y = ..density..), bins = 30, fill = "#90CAF9", color = "gray30") +
  geom_density(fill = "#1976D2", alpha = 0.15) +
  geom_vline(xintercept = mu, color = "#D32F2F", size = 1, linetype = "solid") +
  geom_vline(xintercept = med, color = "#F9A825", size = 1, linetype = "dashed") +
  geom_vline(xintercept = mod, color = "#2E7D32", size = 1, linetype = "dotdash") +
  annotate("text", x = mu, y = Inf, label = paste0("Media: ", mu), vjust = 2.2, color = "#D32F2F", size = 3.5) +
  annotate("text", x = med, y = Inf, label = paste0("Mediana: ", med), vjust = 3.8, color = "#F9A825", size = 3.5) +
  annotate("text", x = mod, y = Inf, label = paste0("Moda: ", mod), vjust = 5.4, color = "#2E7D32", size = 3.5) +
  labs(title = "Distribución de Edad (histograma + densidad)",
       x = "Edad (años)", y = "Densidad") +
  theme_minimal(base_size = 12)

p_hist
```


### Género

### Nacionalidad

### Tiempo Oficial

### Tiempos Parciales



## Análisis Bivariante y Multivariante

<!-- Relación entre variables, correlaciones, visualizaciones conjuntas, etc. -->

## Identificación de Patrones y Formulación de Preguntas

<!-- Detección de tendencias, patrones interesantes y planteamiento de preguntas para análisis futuros. -->
**Posibles preguntas:**

1. Teniendo el ritmo medio en min/km por cada 5km, ver cuándo los atletas cambian ese ritmo(aumentan o disminuyen ritmo): deteccion de estrategias, deteccion de muro (y posibles recomendaciones de entrenamiento), diferencias entre un perfil de corredor y otro...

2. En el caso de poder hacer grupos de carrera si hay los suficientes valores duplicados, se puede ver cómo evolucionan esos grupos, ver qué gente se cae del grupo - teniendo los min/km o cualquier otra medida de velocidad se puede ver qué ritmo son capaces de aguantar los corredores y sacar porcentajes, por ejemplo 3% de atletas aguantaron el ritmo 4'11"/km hasta el final. Si además da tiempo a comparar con otras maratones se pueden comparar porcentajes y dar una explicación por tipo de campeonato o por condiciones de la maratón. *DARLE MÁS DE UNA VUELTA A ESTO*. 

## Conclusiones

<!-- Resumen de hallazgos principales y posibles líneas de investigación. -->
