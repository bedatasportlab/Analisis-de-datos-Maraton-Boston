---
title: "Análisis Exploratorio de Datos. La Maratón de Tokyo 2025."
author:
  - "Alba Martínez de la Hermosa"
  - "Alonso González Romero"
  - "Daniel López Paredes"
date: "2025-10-16"
format: html
toc: true
toc-depth: 2
number-sections: true
lang: es
keywords: ["maratón", "análisis de datos", "Tokyo"]
abstract: "MODIFICAR."
---

# Importación de librerías. 

```{r}
# Importación de todas las librerías usadas durante el informe y breve descripcion
library(readr) # Libreria para poder importar los datos desde un csv.
library(ggplot2) # Libreria para poder hacer gráficos.
library(DT) # Libreria para poder visualizar dataframes en qmd de manera interactiva.
library(hms) # Libreria para poder tratar datos referentes a horas, minutos y segundos.
library(dplyr) # Libreria para poder manipular dataframes.
library(ggplot2) # Libreria para poder hacer gráficos.
library(tidyr) # Libreria para poder transformar dataframes.
library(e1071) # para skewness() y kurtosis()
```

# Introducción
El **maratón de Tokyo 2025** se celebró, en su 18ª edición, el domingo 2 de marzo de 2025. Esta edición forma parte de los World Marathon Majors y abrió la temporada 2025 de los grandes maratones internacionales. El recorrido atraviesa distintos puntos icónicos de la ciudad de Tokyo, estando su inicio frente al edificio del Gobierno Metropolitano y la línea de meta cerca de la estación Tokyo/Gyoko-dori Avenue. El maratón de Tokyo es un evento de gran participación, tanto de atletas de élite como de aficionados. 

En el presente documento se realizará un análisis exploratorio de datos (EDA) con el objetivo de extraer información relevante acerca de los resultados de los corredores que participaron en dicha prueba.

# Presentación y Descripción del Dataset
Los resultados del maratón de Tokyo han sido extraídos a través del siguiente [enlace](https://www.marathon.tokyo/2025/result). La extracción se ha realizado a través de técnicas de Web Scrapping con el objetivo de poder obtener datos relevantes referentes a los resultados de los corredores participantes.

## Importación del Dataset

A continuación, se realiza la correspondiente importación de los datos extraídos:

```{r}
resultadosTokyo2025 <- read_csv(
  "data/Maraton_Tokyo/marathon_tokyo_results_2025.csv",
  col_types = cols(
    BIB = col_integer(),
    Nombre = col_character(),
    Nacionalidad = col_character(),
    Genero = col_character(),
    Edad = col_integer(),
    tiempo_oficial = col_time(format = "%H:%M:%S"),
    parcial_5km = col_time(format = "%H:%M:%S"),
    parcial_10km = col_time(format = "%H:%M:%S"),
    parcial_15km = col_time(format = "%H:%M:%S"),
    parcial_20km = col_time(format = "%H:%M:%S"),
    medio_maraton = col_time(format = "%H:%M:%S"),
    parcial_25km = col_time(format = "%H:%M:%S"),
    parcial_30km = col_time(format = "%H:%M:%S"),
    parcial_35km = col_time(format = "%H:%M:%S"),
    parcial_40km = col_time(format = "%H:%M:%S")
  ),
  quote = "\""
)

# Transformacion a formato dataframe.
resultadosTokyo2025 <- as.data.frame(resultadosTokyo2025)
```


## Descripción del Dataset
El dataframe importado, *resultadosTokyo2025*, consta de las siguientes variables: 

| Variable       | Tipo            | Descripción                                        | Unidades      |
| -------------- | --------------- | -------------------------------------------------- | ------------- |
| BIB            | Numérica/Entero | Número de dorsal asignado al corredor, valor único | Número entero |
| Nombre         | Cadena de texto | Nombre y apellidos del corredor                    | Texto         |
| Nacionalidad   | Cadena de texto | País de procedencia del corredor                   | Texto         |
| Genero         | Categórica      | Género del corredor                                | Texto         |
| Edad           | Numérica/Entero | Edad del corredor                                  | Años          |
| tiempo_oficial | Tiempo          | Tiempo total oficial de la maratón (gross time)    | hh:mm:ss      |
| parcial_5km    | Tiempo          | Tiempo de paso en el km 5                          | hh:mm:ss      |
| parcial_10km   | Tiempo          | Tiempo de paso en el km 10                         | hh:mm:ss      |
| parcial_15km   | Tiempo          | Tiempo de paso en el km 15                         | hh:mm:ss      |
| parcial_20km   | Tiempo          | Tiempo de paso en el km 20                         | hh:mm:ss      |
| medio_maraton  | Tiempo          | Tiempo al paso del medio maratón (21,097 km)       | hh:mm:ss      |
| parcial_25km   | Tiempo          | Tiempo de paso en el km 25                         | hh:mm:ss      |
| parcial_30km   | Tiempo          | Tiempo de paso en el km 30                         | hh:mm:ss      |
| parcial_35km   | Tiempo          | Tiempo de paso en el km 35                         | hh:mm:ss      |
| parcial_40km   | Tiempo          | Tiempo de paso en el km 40                         | hh:mm:ss      |


*Nota: El gross time es el tiempo que tarda un corredor en terminar la maratón desde que se da el pistoletazo de salida, no desde que cruza la línea de inicio de la prueba*
 
## Lectura de una fila

Una vez que conocemos el significado de cada variable por separado, se va a proceder a la lectura de la primera fila del *dataframe* con el objetivo de mejorar la comprensión sobre el formato de los datos:

```{r}
# Lo visualizamos con la libreria DT porque es más interactiva a la hora de generar el documento qmd.
datatable(
  resultadosTokyo2025,
  options = list(
    pageLength = 1, # cuántas filas mostrar
    scrollX = TRUE, # habilita scroll horizontal si la fila es muy ancha
    dom = 't' # solo muestra la tabla sin paginación ni búsqueda
  ),
  rownames = FALSE # quitar número de fila en la tabla
)

```

Se puede observar al corredor **Tadese Takele**, de nacionalidad **Etíope**, que corrió la maratón con el dorsal **número 5**. Tadese completó la maratón a sus 22 años con un tiempo de **2 horas, 3 minutos y 23 segundos**, pudiendose observar sus tiempos de paso cada 5 kilómetros y en el punto de la media maratón. 

## Dimensiones del dataset

```{r}
filas <- nrow(resultadosTokyo2025)
columnas <- ncol(resultadosTokyo2025)
cat(
  "El dataframe resultadosTokyo2025 contiene",
  filas,
  "filas y",
  columnas,
  "columnas."
)
# Elimino el número de filas y columnas con el objetivo de no sobrecargar el environment.
rm(filas, columnas)
```

## Descripción estadística del DataFrame

En este apartado se calculan las estadísticas para comprobar qué datos es necesario limpiar y posteriormente poder hacer un análisis fiable.
```{r}
#Estadísticas de Edad
resumen_edad <- data.frame(
    Minimo = min(resultadosTokyo2025$Edad, na.rm = TRUE),
    Maximo = max(resultadosTokyo2025$Edad, na.rm = TRUE),
    Media = round(mean(resultadosTokyo2025$Edad, na.rm = TRUE),2),
    Nulos = sum(is.na(resultadosTokyo2025$Edad))
)
resumen_edad
```

```{r}
#Estadísticas tiempo
cols_tiempo <- c("tiempo_oficial", "parcial_5km", "parcial_10km", "parcial_15km", "parcial_20km", "medio_maraton", "parcial_25km", "parcial_30km", "parcial_35km", "parcial_40km")

resultadosTokyo2025[cols_tiempo] <- lapply(resultadosTokyo2025[cols_tiempo], as_hms) #columnas a tipo hms

resumen_tiempos <- data.frame(
  Minimo = sapply(resultadosTokyo2025[cols_tiempo], min, na.rm = TRUE),
  Maximo = sapply(resultadosTokyo2025[cols_tiempo], max, na.rm = TRUE),
  Media  = sapply(resultadosTokyo2025[cols_tiempo], function(x) round(mean(x, na.rm = TRUE), 2)),
  Nulos  = sapply(resultadosTokyo2025[cols_tiempo], function(x) sum(is.na(x)))
)
resumen_tiempos
```

```{r}
#Estadísticas tiempos en hms
resumen_tiempos_convertidos <- data.frame (
  Minimo_hms = resumen_tiempos$Minimo <- as_hms((resumen_tiempos$Minimo)),
  Maximo_hms = resumen_tiempos$Maximo <- as_hms((resumen_tiempos$Maximo)),
  Media_hms = resumen_tiempos$Media <- as_hms((resumen_tiempos$Media)),
  Nulos  = sapply(resultadosTokyo2025[cols_tiempo], function(x) sum(is.na(x)))
)
resumen_tiempos_convertidos
```

Gracias a la descripción estadística se ha comprobado que los datos de los tiempos y las edades son coherentes y se han podido observar qué parciales no tienen valores asociados. Cabe destacar que todos los deportistas que aparecen en el dataframe, aunque en algunos casos no estén registrados todos sus parciales, llevaron a término la prueba, ya que el total de valores faltantes que hay en la columna de tiempo oficial es 0.

## Limpieza de datos

### Datos faltantes

En esta sección se busca identificar cuáles son los tiempos parciales que faltan para cada corredor.
```{r}
#Filas con NA
filas_con_na <- resultadosTokyo2025[ rowSums(is.na(resultadosTokyo2025[cols_tiempo])) > 0, ]
which(is.na(resultadosTokyo2025[cols_tiempo]), arr.ind = TRUE)

#Filas con NA en cada columna
filas_con_na <- resultadosTokyo2025[rowSums(is.na(resultadosTokyo2025[cols_tiempo])) > 0, ]
head(filas_con_na, 20)

filas_con_na <- as.data.frame(filas_con_na)
str(filas_con_na)
```

Antes de seguir trabajando sobre el dataframe, es conveniente hacer una copia para trabajar sobre la copia sin tocar los datos originales por los erroes que pueda haber. 

```{r}
df_trabajo <- resultadosTokyo2025
```
```{r}
cols_tiempo <- c("parcial_5km", "parcial_10km", "parcial_15km", "parcial_20km", "medio_maraton", "parcial_25km", "parcial_30km", "parcial_35km", "parcial_40km")

dist <- c(5, 10, 15, 20, 21.0975, 25, 30, 35, 40)

filas_con_na <- df_trabajo[rowSums(is.na(df_trabajo[, cols_tiempo])) > 0, ]
filas_con_na$n_na <- rowSums(is.na(filas_con_na[, cols_tiempo]))

head(filas_con_na[, c(cols_tiempo, "n_na")])
```

Habiendo identificado las filas con valores NA y la situacion de dichos valores en las columnas, se procede a valorar si a qué corredores se les va a estimar algún parcial o no. El criterio es el que aquí sigue:

Si una fila tiene 2 o más parciales sin tiempo registrado consecutivos no se considerará imputable ya que la falta de tan solo dos valores faltantes consecutivos implica un desconocimiento del desarrollo de la prueba durante 15 kilómetros. Asumir un ritmo constante durante 15 kilómetros en una disciplina de duración tan larga como la maratón en atletas amateur (son los que tienen los parciales sin registrar) y en el tramo central de la carrera es irreal.

De esta forma, solo se tendrían en cuenta para imputar aquellas filas cuyos parciales puedan calcularse con el tiempo inmediatamente anterior y/o posterior.

```{r}
filas_con_na$max_na_consec <- sapply(1:nrow(filas_con_na), function(i) {
  elems <- unlist(filas_con_na[i, cols_tiempo])
  na_vec <- is.na(elems)
  if(all(!na_vec)) return(0)
  max(rle(na_vec)$lengths[rle(na_vec)$values == TRUE])
})
```

```{r}
filas_con_na$clasificacion <- ifelse(
  filas_con_na$max_na_consec >= 2,
  "descartar",
  "imputable"
)
filas_con_na$descarte <- filas_con_na$clasificacion == "descartar"
filas_para_imputar <- filas_con_na[filas_con_na$descarte == FALSE, ]
```

Recogidos los valores que pueden imputarse se procede a destacar 4 casos distintos según cuál sea el parcial desconocido:

Si no está el parcial de 5km se debe tener en cuenta que el ritmo en el primer tramo de la maratón es en promedio un 5% más rápido que el ritmo de tramos posteriores.

Si el kilómetro 40 es el faltante, al hacer los cálculos hay que considerar que desde el parcial 35 hay 5km de distancia pero para la llegada a la meta hay 2km y 195m.
De igual manera, si no se sabe el tiempo de paso por la media maratón es preciso saber que desde el parcial del kilómetro 20 hay 1km y 96m de distancia y 3km 904m hasta el kilómetro 25.

El cuarto caso es el de un parcial que pueda calcularse con el tiempo de paso inmediatamente anterior y posterior a él.

```{r}
imputar_parciales <- function(tiempos, dist, cols_tiempo) {
  if (!inherits(tiempos, "hms")) tiempos <- hms::as_hms(tiempos)
  idx_medio <- which(cols_tiempo == "medio_maraton")
  
  for (i in seq_along(tiempos)) {
    if (i == idx_medio) next
    if (is.na(tiempos[i])) {
      
      prev_idx <- max(which(!is.na(tiempos[1:(i - 1)])), na.rm = TRUE)
      next_idx <- min(which(!is.na(tiempos[(i + 1):length(tiempos)])), na.rm = TRUE)
      if (is.finite(next_idx)) next_idx <- next_idx + i
      if (is.finite(prev_idx) && is.finite(next_idx)) {
        t_prev <- tiempos[prev_idx]
        t_next <- tiempos[next_idx]
        d_prev <- dist[prev_idx]
        d_next <- dist[next_idx]
        d_missing <- dist[i]
        tiempos[i] <- t_prev + (t_next - t_prev) * ((d_missing - d_prev) / (d_next - d_prev)) #interpolación lineal estándar
      }
    }
  }
  return(tiempos)
}
primera_imputacion <- as.data.frame(
  t(apply(filas_para_imputar[cols_tiempo], 1, imputar_parciales, dist = dist, cols_tiempo = cols_tiempo))
)
colnames(primera_imputacion) <- cols_tiempo
primera_imputacion[cols_tiempo] <-
  lapply(primera_imputacion[cols_tiempo], hms::as_hms)
```

```{r}
#Añadir a primera_imputacion la imputacion de medio_maraton

idx_20 <- which(cols_tiempo == "parcial_20km")
idx_media <- which(cols_tiempo == "medio_maraton")
idx_25 <- which(cols_tiempo == "parcial_25km")

filas_na <- which(is.na(primera_imputacion$medio_maraton))

d_20 <- dist[idx_20]
d_media <- dist[idx_media]
d_25 <- dist[idx_25]

primera_imputacion$medio_maraton[filas_na] <- hms::as_hms(
  (primera_imputacion$parcial_20km[filas_na] * (d_25 - d_media) +
     primera_imputacion$parcial_25km[filas_na] * (d_media - d_20)) / (d_25 - d_20)
)
```

```{r}
#Añadir a primera_imputacion la imputacion de parcial_5km

idx_5 <- which(cols_tiempo == "parcial_5km")
idx_10 <- which(cols_tiempo == "parcial_10km")

filas_na_5 <- which(is.na(primera_imputacion$parcial_5km))

d_5 <- dist[idx_5]
d_10 <- dist[idx_10]

factor_salida <- 0.95  # 5% más rápida

primera_imputacion$parcial_5km[filas_na_5] <- hms::as_hms(
  (primera_imputacion$parcial_10km[filas_na_5] - hms::as_hms(0)) * factor_salida * (d_5 / d_10)
)
```

```{r}
#Añadir a primera_imputacion la imputacion del parcial_40km

idx_35 <- which(cols_tiempo == "parcial_35km")
idx_40 <- which(cols_tiempo == "parcial_40km")
d_35 <- dist[idx_35]
d_40 <- dist[idx_40]

filas_na_40 <- which(is.na(primera_imputacion$parcial_40km))
primera_imputacion$parcial_40km[filas_na_40] <- hms::as_hms(
  primera_imputacion$parcial_35km[filas_na_40] +
    (primera_imputacion$parcial_35km[filas_na_40] - primera_imputacion$parcial_30km[filas_na_40]) *
    ((d_40 - d_35) / (d_35 - dist[idx_35 - 1]))
)
```

```{r}
redondear_hms <- function(x) {
  seg_total <- as.numeric(x)
  seg_total_rounded <- round(seg_total)
  hms::as_hms(seg_total_rounded)
}
primera_imputacion[cols_tiempo] <- lapply(
  primera_imputacion[cols_tiempo],
  redondear_hms
)
```

```{r}
df_trabajo[rownames(filas_para_imputar), cols_tiempo] <- primera_imputacion
resultadosTokyo2025 <- df_trabajo
print("Datos faltantes imputados")
```

### Valores únicos - datos duplicados

```{r}
cols_para_duplicados <- c(cols_tiempo, "BIB")
valores_unicos <- lapply(trabajo_df[cols_para_duplicados], unique)
valores_unicos
```

```{r}
n_unicos <- sapply(valores_unicos, length) #Valores únicos por columna
n_filas <- nrow(trabajo_df) # Número de filas total

for(col in names(n_unicos)){ # Comprobar si hay duplicados
  if(n_unicos[col] == n_filas){
    message(paste("Columna", col, ": Ningún valor duplicado"))
  } else {
    message(paste("Columna", col, "tiene duplicados"))
  }
}
```

En este apartado se ha comprobado que no hay ningún corredor duplicado y que en todos los parciales hay pocos valores duplicados, lo que es coherente con el formato de carrera de una maratón. Es raro que haya grupos de carrera grandes en una disciplina de tan larga duración y con participantes de niveles tan dispares.

```{r}
duplicados_df <- data.frame( # Crear un data frame vacío para guardar los duplicados
  columna = character(),
  valor = character(),
  frecuencia = integer(),
  stringsAsFactors = FALSE
)
for (col in cols_tiempo) { # Recorrer las columnas de tiempo
  freq <- table(trabajo_df[[col]])           # frecuencia de cada valor
  duplicados <- freq[freq > 1]               # solo los que aparecen más de una vez
  
  if (length(duplicados) > 0) {
    temp <- data.frame(
      columna = col,
      valor = names(duplicados),
      frecuencia = as.integer(duplicados),
      stringsAsFactors = FALSE
    )
    duplicados_df <- rbind(duplicados_df, temp)
  }
}
duplicados_df
```

```{r}
for(col in cols_tiempo){
  freq <- table(trabajo_df[[col]])  # cuenta cuántas veces aparece cada valor
  duplicados <- freq[freq > 1]               # filtra solo los que aparecen más de una vez
  if(length(duplicados) > 0){
    cat("\nColumna:", col, "\n")
    print(duplicados)
  } else {
    cat("\nColumna:", col, "→ Ningún duplicado\n")
  }
}
```

### Transformación de datos

### Comprobación de calidad antes del análisis

```{r}
sapply(resultadosTokyo2025[cols_tiempo], function(x) sum(is.na(x)))

resultadosTokyo2025$n_na_fila <- rowSums(is.na(resultadosTokyo2025[cols_tiempo]))
head(resultadosTokyo2025[, c("BIB", "n_na_fila")])
```

**¿¿Eliminamos las filas que se han quedado con NA después de la imputación??**

```{r}
cols_validar <- c("tiempo_oficial", cols_tiempo, "Edad")

resumen_calidad <- resultadosTokyo2025 %>%
  select(all_of(cols_validar)) %>%
  summarise(across(everything(), list(
    Minimo = ~if(is.numeric(.)) min(., na.rm = TRUE) else as_hms(min(., na.rm = TRUE)),
    Maximo = ~if(is.numeric(.)) max(., na.rm = TRUE) else as_hms(max(., na.rm = TRUE)),
    Media  = ~if(is.numeric(.)) mean(., na.rm = TRUE) else as_hms(mean(as.numeric(.), na.rm = TRUE))
  ), .names = "{.col}_{.fn}"))

resumen_calidad_tidy <- t(resumen_calidad)
colnames(resumen_calidad_tidy) <- "Valor"

resumen_calidad_tidy
```

## Análisis Univariante

DF TEMPORAL PARA EMPEZAR SECCION

```{r}
df_seconds <- resultadosTokyo2025 %>%
  mutate(
    across(
      matches("^tiempo_oficial$|^parcial_\\d+km$|^medio_maraton$"),
      ~ as.numeric(.x)
    )
  )

# Vista previa
glimpse(df_seconds)
```

<!-- Exploración de variables individuales: distribuciones, estadísticos descriptivos, etc. -->

Bajo este análisis se examinará cada variable del conjunto de datos para resumir su distribución, principales características y tendencias. Este tipo de análisis se centra en **una sola variable a la vez**, sin tener en cuenta su relación con otras, y permite obtener una primera descripción general de los datos. A continuación se revisa cada variable del dataset para observar sus principales características estadísticas.

### Edad

Esta variable indica la **edad** de los corredores que participaron en la maratón. Primero se examinán los principales estadísticos de centralización: media, moda y mediana

```{r}
# Fun. moda que devuelve el valor más frecuente (si hay empates devuelve el primero)
moda <- function(x) {
  x <- x[!is.na(x)]
  if (length(x) == 0) return(NA_real_)
  ux <- unique(x)
  ux[which.max(tabulate(match(x, ux)))]
}

# Estadísticos resumidos (redondeados)
edad_stats <- df_seconds %>%
  summarise(
    n = sum(!is.na(Edad)),
    n_missing = sum(is.na(Edad)),
    media = round(mean(Edad, na.rm = TRUE), 2),
    mediana = median(Edad, na.rm = TRUE),
    moda = moda(Edad),
  )

datatable(
  edad_stats,
  options = list(dom = 't'),
  rownames = FALSE
)

```

Representado de forma gráfica, en la siguiente figura se observa un histograma con línea de densidad y los correspondientes valores de media, mediana y moda.

```{r}

# Valores para líneas en los gráficos
mu <- edad_stats$media
med <- edad_stats$mediana
mod <- edad_stats$moda

p_hist <- ggplot(df_seconds, aes(x = Edad)) +
  geom_histogram(aes(y = ..density..), bins = 30, fill = "#90CAF9", color = "gray30") +
  geom_density(fill = "#1976D2", alpha = 0.15) +
  geom_vline(xintercept = mu, color = "#D32F2F", size = 1, linetype = "solid") +
  geom_vline(xintercept = med, color = "#F9A825", size = 1, linetype = "dashed") +
  geom_vline(xintercept = mod, color = "#2E7D32", size = 1, linetype = "dotdash") +
  annotate("text", x = mu, y = Inf, label = paste0("Media: ", mu), vjust = 2.2, color = "#D32F2F", size = 3.5) +
  annotate("text", x = med, y = Inf, label = paste0("Mediana: ", med), vjust = 3.8, color = "#F9A825", size = 3.5) +
  annotate("text", x = mod, y = Inf, label = paste0("Moda: ", mod), vjust = 5.4, color = "#2E7D32", size = 3.5) +
  labs(title = "Distribución de Edad (histograma + densidad)",
       x = "Edad (años)", y = "Densidad") +
  theme_minimal(base_size = 12)

p_hist
```


### Género

### Nacionalidad

### Tiempo Oficial

### Tiempos Parciales



## Análisis Bivariante y Multivariante

<!-- Relación entre variables, correlaciones, visualizaciones conjuntas, etc. -->

## Identificación de Patrones y Formulación de Preguntas

<!-- Detección de tendencias, patrones interesantes y planteamiento de preguntas para análisis futuros. -->
**Posibles preguntas:**

*Conociendo el ritmo:*

1. ¿En qué momento o momentos hay un cambio notable en el ritmo de los atletas?

2. ¿Hay algún cambio que sea común a todos los atletas independientemente del nivel?
  Puede indicar irregularidad del terreno, cambio en los elementos ambientales, presencia de público...

3. ¿Qué estrategia de carrera indica ese cambio de ritmo? 
  (Positiva (disminuye el tiempo según avanza la carrera)/negativa(aumenta el tiempo)/even pace(igual)/parabólica(primeros y últimos km más rápidos que los centrales))

4. ¿Qué factores psicofisiológicos están detrás de los cambios de ritmo?

5. ¿Se pueden identificar perfiles de corredores según cuándo se cambie el ritmo? ¿Según la estrategia que se utilice?

6. ¿Qué relación hay entre la estrategia (variación o no del ritmo en los parciales) y el tiempo final? 
  ¿Qué estrategias se repiten más en los mejores y peores tiempos finales?

7. ¿Qué relación hay entre los procesos piscofisiológicos y la estrategia de carrera?

9. ¿Qué relación hay entre los facotres ambientales y la estrategia? Crear perfil de maratón.

10. En un mismo recorrido y para un atleta del mismo nivel, ¿la estrategia puede ser distinta según el tipo de competición que sea? (Major, campeonato del mundo, JJOO...)

11. ¿Hay relación entre el sexo y la estrategia? ¿A qué podría deberse?

*La carrera en números:*

1. ¿Cuántos atletas bajaron de 2h10? ¿2h30? ¿3h00?

2. ¿Qué porcentaje de atletas llevó x ritmo?

3. ¿A cuánto tiempo y porcentaje de tiempo se quedaron los mejores tiempos masculino y femenino del récord del mundo?

4. ¿Qué nacionalidad tuvo el mejor rendimiento?

5. ¿Alguna marca entra en el top10 histórico?

6. ¿Cuál ha sido el lapso de tiempo al entrar en meta entre los tres primeros?

7. ¿Cuántos atletas olímpicos/internacionales han participado?


## Conclusiones

<!-- Resumen de hallazgos principales y posibles líneas de investigación. -->