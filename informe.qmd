---
title: "Análisis Exploratorio de Datos. La Maratón de Tokyo 2025."
author:
  - "Alba Martínez de la Hermosa"
  - "Alonso González Romero"
  - "Daniel López Paredes"
date: "2025-10-16"
format: html
toc: true
toc-depth: 2
number-sections: true
lang: es
keywords: ["maratón", "análisis de datos", "Tokyo"]
abstract: "MODIFICAR."
---

# Importación de librerías. 

```{r}
# Importación de todas las librerías usadas durante el informe y breve descripcion
library(readr) # Libreria para poder importar los datos desde un csv.
library(ggplot2) # Libreria para poder hacer gráficos.
library(DT) # Libreria para poder visualizar dataframes en qmd de manera interactiva.
library(hms) # Libreria para poder tratar datos referentes a horas, minutos y segundos.
library(dplyr) # Libreria para poder manipular dataframes.
library(ggplot2) # Libreria para poder hacer gráficos.
library(tidyr) # Libreria para poder transformar dataframes.
library(e1071) # para skewness() y kurtosis()
```

# Introducción
El **maratón de Tokyo 2025** se celebró, en su 18ª edición, el domingo 2 de marzo de 2025. Esta edición forma parte de los World Marathon Majors y abrió la temporada 2025 de los grandes maratones internacionales. El recorrido atraviesa distintos puntos icónicos de la ciudad de Tokyo, estando su inicio frente al edificio del Gobierno Metropolitano y la línea de meta cerca de la estación Tokyo/Gyoko-dori Avenue. El maratón de Tokyo es un evento de gran participación, tanto de atletas de élite como de aficionados. 

En el presente documento se realizará un análisis exploratorio de datos (EDA) con el objetivo de extraer información relevante acerca de los resultados de los corredores que participaron en dicha prueba.

# Presentación y Descripción del Dataset
Los resultados del maratón de Tokyo han sido extraídos a través del siguiente [enlace](https://www.marathon.tokyo/2025/result). La extracción se ha realizado a través de técnicas de Web Scrapping con el objetivo de poder obtener datos relevantes referentes a los resultados de los corredores participantes.

## Importación del Dataset

A continuación, se realiza la correspondiente importación de los datos extraídos:

```{r}
resultadosTokyo2025 <- read_csv(
  "data/Maraton_Tokyo/marathon_tokyo_results_2025.csv",
  col_types = cols(
    BIB = col_integer(),
    Nombre = col_character(),
    Nacionalidad = col_character(),
    Genero = col_character(),
    Edad = col_integer(),
    tiempo_oficial = col_time(format = "%H:%M:%S"),
    parcial_5km = col_time(format = "%H:%M:%S"),
    parcial_10km = col_time(format = "%H:%M:%S"),
    parcial_15km = col_time(format = "%H:%M:%S"),
    parcial_20km = col_time(format = "%H:%M:%S"),
    medio_maraton = col_time(format = "%H:%M:%S"),
    parcial_25km = col_time(format = "%H:%M:%S"),
    parcial_30km = col_time(format = "%H:%M:%S"),
    parcial_35km = col_time(format = "%H:%M:%S"),
    parcial_40km = col_time(format = "%H:%M:%S")
  ),
  quote = "\""
)

# Transformacion a formato dataframe.
resultadosTokyo2025 <- as.data.frame(resultadosTokyo2025)
```


## Descripción del Dataset
El dataframe importado, *resultadosTokyo2025*, consta de las siguientes variables: 

| Variable       | Tipo            | Descripción                                        | Unidades      |
| -------------- | --------------- | -------------------------------------------------- | ------------- |
| BIB            | Numérica/Entero | Número de dorsal asignado al corredor, valor único | Número entero |
| Nombre         | Cadena de texto | Nombre y apellidos del corredor                    | Texto         |
| Nacionalidad   | Cadena de texto | País de procedencia del corredor                   | Texto         |
| Genero         | Categórica      | Género del corredor                                | Texto         |
| Edad           | Numérica/Entero | Edad del corredor                                  | Años          |
| tiempo_oficial | Tiempo          | Tiempo total oficial de la maratón (gross time)    | hh:mm:ss      |
| parcial_5km    | Tiempo          | Tiempo de paso en el km 5                          | hh:mm:ss      |
| parcial_10km   | Tiempo          | Tiempo de paso en el km 10                         | hh:mm:ss      |
| parcial_15km   | Tiempo          | Tiempo de paso en el km 15                         | hh:mm:ss      |
| parcial_20km   | Tiempo          | Tiempo de paso en el km 20                         | hh:mm:ss      |
| medio_maraton  | Tiempo          | Tiempo al paso del medio maratón (21,097 km)       | hh:mm:ss      |
| parcial_25km   | Tiempo          | Tiempo de paso en el km 25                         | hh:mm:ss      |
| parcial_30km   | Tiempo          | Tiempo de paso en el km 30                         | hh:mm:ss      |
| parcial_35km   | Tiempo          | Tiempo de paso en el km 35                         | hh:mm:ss      |
| parcial_40km   | Tiempo          | Tiempo de paso en el km 40                         | hh:mm:ss      |


*Nota: El gross time es el tiempo que tarda un corredor en terminar la maratón desde que se da el pistoletazo de salida, no desde que cruza la línea de inicio de la prueba*
 
## Lectura de una fila

Una vez que conocemos el significado de cada variable por separado, se va a proceder a la lectura de la primera fila del *dataframe* con el objetivo de mejorar la comprensión sobre el formato de los datos:

```{r}
# Lo visualizamos con la libreria DT porque es más interactiva a la hora de generar el documento qmd.
datatable(
  resultadosTokyo2025,
  options = list(
    pageLength = 1, # cuántas filas mostrar
    scrollX = TRUE, # habilita scroll horizontal si la fila es muy ancha
    dom = 't' # solo muestra la tabla sin paginación ni búsqueda
  ),
  rownames = FALSE # quitar número de fila en la tabla
)

```

Se puede observar al corredor **Tadese Takele**, de nacionalidad **Etíope**, que corrió la maratón con el dorsal **número 5**. Tadese completó la maratón a sus 22 años con un tiempo de **2 horas, 3 minutos y 23 segundos**, pudiendose observar sus tiempos de paso cada 5 kilómetros y en el punto de la media maratón. 

## Dimensiones del dataset

```{r}
filas <- nrow(resultadosTokyo2025)
columnas <- ncol(resultadosTokyo2025)
cat(
  "El dataframe resultadosTokyo2025 contiene",
  filas,
  "filas y",
  columnas,
  "columnas."
)
# Elimino el número de filas y columnas con el objetivo de no sobrecargar el environment.
rm(filas, columnas)
```

## Descripción estadística del DataFrame

En este apartado se calculan las estadísticas para comprobar qué datos es necesario limpiar y posteriormente poder hacer un análisis fiable.
```{r}
#Estadísticas de Edad
resumen_edad <- data.frame(
    Minimo = min(resultadosTokyo2025$Edad, na.rm = TRUE),
    Maximo = max(resultadosTokyo2025$Edad, na.rm = TRUE),
    Media = round(mean(resultadosTokyo2025$Edad, na.rm = TRUE),2),
    Nulos = sum(is.na(resultadosTokyo2025$Edad))
)
resumen_edad
```

```{r}
#Estadísticas tiempo
cols_tiempo <- c("tiempo_oficial", "parcial_5km", "parcial_10km", "parcial_15km", "parcial_20km", "medio_maraton", "parcial_25km", "parcial_30km", "parcial_35km", "parcial_40km")

resultadosTokyo2025[cols_tiempo] <- lapply(resultadosTokyo2025[cols_tiempo], as_hms) #columnas a tipo hms

resumen_tiempos <- data.frame(
  Minimo = sapply(resultadosTokyo2025[cols_tiempo], min, na.rm = TRUE),
  Maximo = sapply(resultadosTokyo2025[cols_tiempo], max, na.rm = TRUE),
  Media  = sapply(resultadosTokyo2025[cols_tiempo], function(x) round(mean(x, na.rm = TRUE), 2)),
  Nulos  = sapply(resultadosTokyo2025[cols_tiempo], function(x) sum(is.na(x)))
)
resumen_tiempos
```

```{r}
#Estadísticas tiempos en hms
resumen_tiempos_convertidos <- data.frame (
  Minimo_hms = resumen_tiempos$Minimo <- as_hms((resumen_tiempos$Minimo)),
  Maximo_hms = resumen_tiempos$Maximo <- as_hms((resumen_tiempos$Maximo)),
  Media_hms = resumen_tiempos$Media <- as_hms((resumen_tiempos$Media)),
  Nulos  = sapply(resultadosTokyo2025[cols_tiempo], function(x) sum(is.na(x)))
)
resumen_tiempos_convertidos
```

Gracias a la descripción estadística se ha comprobado que los datos de los tiempos y las edades son coherentes y se han podido observar qué parciales no tienen valores asociados. Cabe destacar que todos los deportistas que aparecen en el dataframe, aunque en algunos casos no estén registrados todos sus parciales, llevaron a término la prueba, ya que el total de valores faltantes que hay en la columna de tiempo oficial es 0.

## Limpieza de datos

### Datos faltantes

En esta sección se busca identificar cuáles son los tiempos parciales que faltan para cada corredor.
```{r}
#Filas con NA
filas_con_na <- resultadosTokyo2025[ rowSums(is.na(resultadosTokyo2025[cols_tiempo])) > 0, ]
which(is.na(resultadosTokyo2025[cols_tiempo]), arr.ind = TRUE)

#Filas con NA en cada columna
filas_con_na <- resultadosTokyo2025[rowSums(is.na(resultadosTokyo2025[cols_tiempo])) > 0, ]
head(filas_con_na, 20)

filas_con_na <- as.data.frame(filas_con_na)
str(filas_con_na)
```

Antes de seguir trabajando sobre el dataframe, es conveniente hacer una copia para trabajar sobre la copia sin tocar los datos originales por los erroes que pueda haber. 

```{r}
df_trabajo <- resultadosTokyo2025
```
```{r}
cols_tiempo <- c("parcial_5km", "parcial_10km", "parcial_15km", "parcial_20km", "medio_maraton", "parcial_25km", "parcial_30km", "parcial_35km", "parcial_40km")

filas_con_na <- df_trabajo[rowSums(is.na(df_trabajo[, cols_tiempo])) > 0, ]
filas_con_na$n_na <- rowSums(is.na(filas_con_na[, cols_tiempo]))

head(filas_con_na[, c(cols_tiempo, "n_na")])
```

Habiendo identificado las filas con valores NA y la situacion de dichos valores en las columnas, se procede a valorar si a qué corredores se les va a estimar algún parcial o no. El criterio es el que aquí sigue:

Si una fila tiene 2 o más parciales sin tiempo registrado consecutivos no se considerará imputable ya que la falta de tan solo dos valores faltantes consecutivos implica un desconocimiento del desarrollo de la prueba durante 15 kilómetros. Asumir un ritmo constante durante 15 kilómetros en una disciplina de duración tan larga como la maratón en atletas amateur (son los que tienen los parciales sin registrar) y en el tramo central de la carrera es irreal.

De esta forma, solo se tendrían en cuenta para imputar aquellas filas cuyos parciales puedan calcularse con el tiempo inmediatamente anterior y/o posterior.

```{r}
trabajo_df <- resultadosTokyo2025
```
```{r}
filas_con_na$max_na_consec <- sapply(1:nrow(filas_con_na), function(i) {
  elems <- unlist(filas_con_na[i, cols_tiempo])
  na_vec <- is.na(elems)
  if(all(!na_vec)) return(0)
  max(rle(na_vec)$lengths[rle(na_vec)$values == TRUE])
})
```

```{r}
# Clasificar filas
filas_con_na$clasificacion <- ifelse(
  filas_con_na$max_na_consec >= 2,
  "descartar",
  "imputable"
)
# Columna de descarte y filas a imputar
filas_con_na$descarte <- filas_con_na$clasificacion == "descartar"
filas_para_imputar <- filas_con_na[filas_con_na$descarte == FALSE, ]
```

Recogidos los valores que pueden imputarse se procede a destacar 4 casos distintos según cuál sea el parcial desconocido:

Si no está el parcial de 5km se debe tener en cuenta que el ritmo en el primer tramo de la maratón es en promedio un 5% más rápido que el ritmo de tramos posteriores.

Si el kilómetro 40 es el faltante, al hacer los cálculos hay que considerar que desde el parcial 35 hay 5km de distancia pero para la llegada a la meta hay 2km y 195m.
De igual manera, si no se sabe el tiempo de paso por la media maratón es preciso saber que desde el parcial del kilómetro 20 hay 1km y 96m de distancia y 3km 904m hasta el kilómetro 25.

El cuarto caso es el de un parcial que pueda calcularse con el tiempo de paso inmediatamente anterior y posterior a él.

```{r}
trabajo_df <- resultadosTokyo2025
```

```{r}

# Interpolacion parciales que no son extremos (parcial_5km o parcial_40km) ni medio_maraton

library(hms)

imputar_parciales <- function(tiempos, dist, cols_tiempo) {
  # Asegurar que los tiempos son hms
  if (!inherits(tiempos, "hms")) {
    tiempos <- hms::as_hms(tiempos)
  }

  # Identificar la posición del medio maratón
  idx_medio <- which(cols_tiempo == "medio_maraton")

  for (i in seq_along(tiempos)) {
    if (is.na(tiempos[i])) {

      # --- Buscar el índice previo no NA ---
      prev_idx <- max(which(!is.na(tiempos[1:(i - 1)])), na.rm = TRUE)
      if (length(prev_idx) > 0 && is.finite(prev_idx) && prev_idx == idx_medio) {
        prev_idx <- max(which(!is.na(tiempos[1:(prev_idx - 1)])), na.rm = TRUE)
      }

      # --- Buscar el índice posterior no NA ---
      next_idx <- min(which(!is.na(tiempos[(i + 1):length(tiempos)])), na.rm = TRUE)
      if (is.finite(next_idx)) next_idx <- next_idx + i
      if (length(next_idx) > 0 && is.finite(next_idx) && next_idx == idx_medio) {
        next_idx <- min(which(!is.na(tiempos[(idx_medio + 1):length(tiempos)])), na.rm = TRUE) + idx_medio
      }

      # --- Interpolación lineal estándar ---
      if (is.finite(prev_idx) && is.finite(next_idx)) {
        t_prev <- tiempos[prev_idx]
        t_next <- tiempos[next_idx]
        d_prev <- dist[prev_idx]
        d_next <- dist[next_idx]
        d_missing <- dist[i]

        tiempos[i] <- t_prev + (t_next - t_prev) * ((d_missing - d_prev) / (d_next - d_prev))
      }
    }
  }

  return(tiempos)
}
```

```{r}
cols_tiempo <- c("parcial_5km", "parcial_10km", "parcial_15km", "parcial_20km", "medio_maraton", "parcial_25km", "parcial_30km", "parcial_35km", "parcial_40km") 

dist <- c(5, 10, 15, 20, 21.0975, 25, 30, 35, 40)

# Aplicar imputación por fila
primera_imputacion <- as.data.frame(
  t(apply(filas_para_imputar[cols_tiempo], 1, imputar_parciales,
          dist = dist, cols_tiempo = cols_tiempo))
)

colnames(primera_imputacion) <- cols_tiempo

# Mantener formato hms
primera_imputacion[cols_tiempo] <-
  lapply(primera_imputacion[cols_tiempo], hms::as_hms)
```

**Aqui está todo imputado menos parcial_5km, parcial_40 y medio_maraton está mal imputado**

### Valores únicos - datos duplicados

```{r}
cols_para_duplicados <- c(cols_tiempo, "BIB")
valores_unicos <- lapply(trabajo_df[cols_para_duplicados], unique)
valores_unicos
```

```{r}
#Valores únicos por columna
n_unicos <- sapply(valores_unicos, length)

# Número de filas total
n_filas <- nrow(trabajo_df)

# Comprobar si hay duplicados
for(col in names(n_unicos)){
  if(n_unicos[col] == n_filas){
    message(paste("Columna", col, ": Ningún valor duplicado"))
  } else {
    message(paste("Columna", col, "tiene duplicados"))
  }
}
```

En este apartado se ha comprobado que no hay ningún corredor duplicado y que en todos los parciales hay pocos valores duplicados, lo que es coherente con el formato de carrera de una maratón. Es raro que haya grupos de carrera grandes en una disciplina de tan larga duración y con participantes de niveles tan dispares.

```{r}
# Crear un data frame vacío para guardar los duplicados
duplicados_df <- data.frame(
  columna = character(),
  valor = character(),
  frecuencia = integer(),
  stringsAsFactors = FALSE
)

# Recorrer las columnas de tiempo
for (col in cols_tiempo) {
  freq <- table(trabajo_df[[col]])           # frecuencia de cada valor
  duplicados <- freq[freq > 1]               # solo los que aparecen más de una vez
  
  if (length(duplicados) > 0) {
    temp <- data.frame(
      columna = col,
      valor = names(duplicados),
      frecuencia = as.integer(duplicados),
      stringsAsFactors = FALSE
    )
    duplicados_df <- rbind(duplicados_df, temp)
  }
}

# Mostrar el resultado
duplicados_df

```

```{r}
for(col in cols_tiempo){
  freq <- table(trabajo_df[[col]])  # cuenta cuántas veces aparece cada valor
  duplicados <- freq[freq > 1]               # filtra solo los que aparecen más de una vez
  if(length(duplicados) > 0){
    cat("\nColumna:", col, "\n")
    print(duplicados)
  } else {
    cat("\nColumna:", col, "→ Ningún duplicado\n")
  }
}
```

### Transformación de datos

### Validación de rangos

### Comprobación de calidad antes del análisis

## Análisis Univariante

DF TEMPORAL PARA EMPEZAR SECCION

```{r}
df_seconds <- resultadosTokyo2025 %>%
  mutate(
    across(
      matches("^tiempo_oficial$|^parcial_\\d+km$|^medio_maraton$"),
      ~ as.numeric(.x)
    )
  )

# Vista previa
glimpse(df_seconds)
```

<!-- Exploración de variables individuales: distribuciones, estadísticos descriptivos, etc. -->

Bajo este análisis se examinará cada variable del conjunto de datos para resumir su distribución, principales características y tendencias. Este tipo de análisis se centra en **una sola variable a la vez**, sin tener en cuenta su relación con otras, y permite obtener una primera descripción general de los datos. A continuación se revisa cada variable del dataset para observar sus principales características estadísticas.

### Edad

Esta variable indica la **edad** de los corredores que participaron en la maratón. Primero se examinán los principales estadísticos de centralización: media, moda y mediana

```{r}
# Fun. moda que devuelve el valor más frecuente (si hay empates devuelve el primero)
moda <- function(x) {
  x <- x[!is.na(x)]
  if (length(x) == 0) return(NA_real_)
  ux <- unique(x)
  ux[which.max(tabulate(match(x, ux)))]
}

# Estadísticos resumidos (redondeados)
edad_stats <- df_seconds %>%
  summarise(
    n = sum(!is.na(Edad)),
    n_missing = sum(is.na(Edad)),
    media = round(mean(Edad, na.rm = TRUE), 2),
    mediana = median(Edad, na.rm = TRUE),
    moda = moda(Edad),
  )

datatable(
  edad_stats,
  options = list(dom = 't'),
  rownames = FALSE
)

```

Representado de forma gráfica, en la siguiente figura se observa un histograma con línea de densidad y los correspondientes valores de media, mediana y moda.

```{r}

# Valores para líneas en los gráficos
mu <- edad_stats$media
med <- edad_stats$mediana
mod <- edad_stats$moda

p_hist <- ggplot(df_seconds, aes(x = Edad)) +
  geom_histogram(aes(y = ..density..), bins = 30, fill = "#90CAF9", color = "gray30") +
  geom_density(fill = "#1976D2", alpha = 0.15) +
  geom_vline(xintercept = mu, color = "#D32F2F", size = 1, linetype = "solid") +
  geom_vline(xintercept = med, color = "#F9A825", size = 1, linetype = "dashed") +
  geom_vline(xintercept = mod, color = "#2E7D32", size = 1, linetype = "dotdash") +
  annotate("text", x = mu, y = Inf, label = paste0("Media: ", mu), vjust = 2.2, color = "#D32F2F", size = 3.5) +
  annotate("text", x = med, y = Inf, label = paste0("Mediana: ", med), vjust = 3.8, color = "#F9A825", size = 3.5) +
  annotate("text", x = mod, y = Inf, label = paste0("Moda: ", mod), vjust = 5.4, color = "#2E7D32", size = 3.5) +
  labs(title = "Distribución de Edad (histograma + densidad)",
       x = "Edad (años)", y = "Densidad") +
  theme_minimal(base_size = 12)

p_hist
```


### Género

### Nacionalidad

### Tiempo Oficial

### Tiempos Parciales



## Análisis Bivariante y Multivariante

<!-- Relación entre variables, correlaciones, visualizaciones conjuntas, etc. -->

## Identificación de Patrones y Formulación de Preguntas

<!-- Detección de tendencias, patrones interesantes y planteamiento de preguntas para análisis futuros. -->
**Posibles preguntas:**

1. Teniendo el ritmo medio en min/km por cada 5km, ver cuándo los atletas cambian ese ritmo(aumentan o disminuyen ritmo): deteccion de estrategias, deteccion de muro (y posibles recomendaciones de entrenamiento), diferencias entre un perfil de corredor y otro...

2. En el caso de poder hacer grupos de carrera si hay los suficientes valores duplicados, se puede ver cómo evolucionan esos grupos, ver qué gente se cae del grupo - teniendo los min/km o cualquier otra medida de velocidad se puede ver qué ritmo son capaces de aguantar los corredores y sacar porcentajes, por ejemplo 3% de atletas aguantaron el ritmo 4'11"/km hasta el final. Si además da tiempo a comparar con otras maratones se pueden comparar porcentajes y dar una explicación por tipo de campeonato o por condiciones de la maratón. *DARLE MÁS DE UNA VUELTA A ESTO*. 

## Conclusiones

<!-- Resumen de hallazgos principales y posibles líneas de investigación. -->
